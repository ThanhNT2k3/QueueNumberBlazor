@page "/tm/dashboard"
@rendermode InteractiveServer
@layout Layout.TMLayout
@inject ITicketService TicketService
@inject ICounterService CounterService
@inject IUserService UserService
@inject QMS.Web.Services.AuthenticationStateService AuthState
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime

<style>
    .tm-dashboard {
        max-width: 1400px;
        margin: 0 auto;
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1.5rem;
        margin-bottom: 2rem;
    }

    .chart-card {
        background: white;
        border-radius: 16px;
        padding: 2rem;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        margin-bottom: 2rem;
    }

    .chart-title {
        font-size: 18px;
        font-weight: 700;
        color: #1e293b;
        margin-bottom: 1.5rem;
    }
</style>

<div class="tm-dashboard">
    <!-- Header -->
    <PageHeader Title="Dashboard Analytics" 
                Subtitle="@($"Monitor and analyze queue performance for {(AuthState.BranchId.HasValue ? "your branch" : "all branches")}")"
                Icon="bi bi-graph-up" />

    <!-- Filters -->
    <!-- Filters -->
    <div class="card p-4 mb-4 border-0 shadow-sm" style="border-radius: 16px;">
        <div class="row g-3 align-items-end">
            <div class="col-md-2">
                <BaseDateInput Label="From Date" @bind-Value="fromDate" ContainerClass="mb-0" />
            </div>
            <div class="col-md-2">
                <BaseDateInput Label="To Date" @bind-Value="toDate" ContainerClass="mb-0" />
            </div>
            <div class="col-md-2">
                <BaseMultiSelect TValue="int" 
                                Label="Counters" 
                                Items="@counterItems" 
                                @bind-SelectedValues="selectedCounterIds"
                                Placeholder="Select counters..."
                                ContainerClass="mb-0" />
            </div>
            <div class="col-md-2">
                <BaseMultiSelect TValue="int" 
                                Label="Staff" 
                                Items="@userItems" 
                                @bind-SelectedValues="selectedUserIds"
                                Placeholder="Select staff..."
                                ContainerClass="mb-0" />
            </div>
            <div class="col-md-4 d-flex gap-2">
                <BaseButton Variant="primary" Class="flex-grow-1" OnClick="ApplyFilters" Icon="bi bi-funnel">
                    Apply
                </BaseButton>
                <BaseButton Variant="outline-success" Class="flex-grow-1" OnClick="ExportReport" Icon="bi bi-download">
                    Export
                </BaseButton>
            </div>
        </div>
    </div>

    <!-- Statistics -->
    <div class="stats-grid">
        <StatCard Icon="bi bi-ticket-perforated" ColorClass="blue" Value="@totalTickets.ToString()" Label="Total Tickets" />
        <StatCard Icon="bi bi-check-circle" ColorClass="green" Value="@completedTickets.ToString()" Label="Completed" />
        <StatCard Icon="bi bi-hourglass-split" ColorClass="yellow" Value="@waitingTickets.ToString()" Label="Waiting" />
        <StatCard Icon="bi bi-x-circle" ColorClass="red" Value="@missedTickets.ToString()" Label="Missed" />
        <StatCard Icon="bi bi-clock" ColorClass="purple" Value="@avgWaitTime" Label="Avg Wait Time (min)" />
    </div>

    <!-- Charts Row -->
    <div class="row mb-4">
        <div class="col-md-8">
            <div class="chart-card h-100">
                <div class="chart-title">
                    <i class="bi bi-bar-chart me-2"></i>
                    Tickets by Hour
                </div>
                <canvas id="ticketsByHourChart"></canvas>
            </div>
        </div>
        <div class="col-md-4">
            <div class="chart-card h-100">
                <div class="chart-title">
                    <i class="bi bi-pie-chart me-2"></i>
                    Ticket Status
                </div>
                <canvas id="ticketStatusChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Tickets Table -->
    <div class="card p-4 border-0 shadow-sm" style="border-radius: 16px;">
        <h5 class="mb-4 fw-bold text-dark">
            <i class="bi bi-table me-2"></i>Ticket Details
        </h5>
        
        <BaseTable IsLoading="@(filteredTickets == null)" 
                   IsEmpty="@(filteredTickets != null && !filteredTickets.Any())"
                   EmptyText="No tickets found for the selected filters"
                   EnablePagination="true"
                   TotalItems="@totalTickets"
                   CurrentPage="@currentPage"
                   PageSize="@pageSize"
                   OnPageChanged="OnPageChanged"
                   OnPageSizeChanged="OnPageSizeChanged">
            <HeaderContent>
                <th>Ticket #</th>
                <th>Service</th>
                <th>Counter</th>
                <th>Staff</th>
                <th>Status</th>
                <th>Started</th>
                <th>Completed</th>
                <th>Duration</th>
            </HeaderContent>
            <BodyContent>
                @if (paginatedTickets != null)
                {
                    @foreach (var ticket in paginatedTickets)
                    {
                        <tr>
                            <td><strong>@ticket.TicketNumber</strong></td>
                            <td>@ticket.ServiceType?.Name</td>
                            <td>@ticket.Counter?.Name</td>
                            <td>@ticket.Staff?.FullName</td>
                            <td>
                                <StatusBadge TicketStatus="@ticket.Status" />
                            </td>
                            <td>@(ticket.StartServiceTime?.ToLocalTime().ToString("HH:mm:ss") ?? "-")</td>
                            <td>@(ticket.EndServiceTime?.ToLocalTime().ToString("HH:mm:ss") ?? "-")</td>
                            <td>@GetServiceDuration(ticket)</td>
                        </tr>
                    }
                }
            </BodyContent>
        </BaseTable>
    </div>
</div>

@code {
    private DateTime fromDate = DateTime.Today;
    private DateTime toDate = DateTime.Today;
    private List<int> selectedCounterIds = new();
    private List<int> selectedUserIds = new();
    
    private IEnumerable<KeyValuePair<int, string>> counterItems => 
        counters?.Select(c => new KeyValuePair<int, string>(c.Id, c.Name)) ?? Enumerable.Empty<KeyValuePair<int, string>>();
    
    private IEnumerable<KeyValuePair<int, string>> userItems => 
        users?.Select(u => new KeyValuePair<int, string>(u.Id, u.FullName)) ?? Enumerable.Empty<KeyValuePair<int, string>>();

    private IEnumerable<Counter>? counters;
    private IEnumerable<User>? users;
    private IEnumerable<Ticket>? filteredTickets;
    
    // Pagination State
    private int currentPage = 1;
    private int pageSize = 10;
    
    private IEnumerable<Ticket>? paginatedTickets => filteredTickets?
        .Skip((currentPage - 1) * pageSize)
        .Take(pageSize);

    private int totalTickets => filteredTickets?.Count() ?? 0;
    private int completedTickets => filteredTickets?.Count(t => t.Status == TicketStatus.Completed) ?? 0;
    private int waitingTickets => filteredTickets?.Count(t => t.Status == TicketStatus.Waiting) ?? 0;
    private int missedTickets => filteredTickets?.Count(t => t.Status == TicketStatus.Missed) ?? 0;
    private string avgWaitTime
    {
        get
        {
            var completed = filteredTickets?.Where(t => t.CompletedAt.HasValue && t.CalledAt.HasValue);
            if (completed == null || !completed.Any()) return "0";
            
            var avgMinutes = completed.Average(t => (t.CompletedAt!.Value - t.CalledAt!.Value).TotalMinutes);
            return avgMinutes.ToString("F1");
        }
    }



    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine($"[TMDashboard] OnInitializedAsync - IsAuthenticated: {AuthState.IsAuthenticated}");
        Console.WriteLine($"[TMDashboard] UserRole: {AuthState.UserRole}");
        Console.WriteLine($"[TMDashboard] BranchId: {AuthState.BranchId}");
        
        // Only check and load if already authenticated
        if (AuthState.IsAuthenticated && AuthState.UserRole == "TM" && AuthState.BranchId.HasValue)
        {
            await LoadData();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !AuthState.IsAuthenticated)
        {
            Navigation.NavigateTo("/login", true);
        }
    }



    private async Task LoadData()
    {
        if (!AuthState.BranchId.HasValue)
        {
            Console.WriteLine("[TMDashboard] No BranchId in LoadData");
            return;
        }

        Console.WriteLine($"[TMDashboard] Loading data for branch {AuthState.BranchId.Value}");
        
        // Load initial data
        counters = await CounterService.GetCountersByBranchAsync(AuthState.BranchId.Value);
        
        // Load users (tellers) for this branch
        users = await UserService.GetTellersByBranchAsync(AuthState.BranchId.Value);

        await ApplyFilters();
        
        Console.WriteLine($"[TMDashboard] Data loaded successfully");
    }

    private async Task ApplyFilters()
    {
        if (!AuthState.BranchId.HasValue) return;

        // Get all tickets for the branch and date range
        var allTickets = await TicketService.GetTicketsByFiltersAsync(
            AuthState.BranchId.Value,
            fromDate,
            toDate,
            null,
            null
        );

        // Apply multi-select filters client-side
        filteredTickets = allTickets;
        
        if (selectedCounterIds.Any())
        {
            filteredTickets = filteredTickets.Where(t => t.CounterId.HasValue && selectedCounterIds.Contains(t.CounterId.Value));
        }
        
        if (selectedUserIds.Any())
        {
            filteredTickets = filteredTickets.Where(t => t.StaffId.HasValue && selectedUserIds.Contains(t.StaffId.Value));
        }

        // Reset pagination when filters change
        currentPage = 1;
        StateHasChanged();
        
        // Render charts after data update
        await RenderCharts();
    }

    private void OnPageChanged(int newPage)
    {
        currentPage = newPage;
    }

    private void OnPageSizeChanged(int newSize)
    {
        pageSize = newSize;
        currentPage = 1; // Reset to first page when page size changes
    }

    private async Task RenderCharts()
    {
        if (filteredTickets == null) return;

        try
        {
            // 1. Prepare Data for Status Chart (Pie)
            var statusData = filteredTickets
                .GroupBy(t => t.Status)
                .Select(g => new { Status = g.Key.ToString(), Count = g.Count() })
                .ToList();

            var statusConfig = new
            {
                type = "doughnut",
                data = new
                {
                    labels = statusData.Select(d => d.Status).ToArray(),
                    datasets = new[]
                    {
                        new
                        {
                            data = statusData.Select(d => d.Count).ToArray(),
                            backgroundColor = new[] { "#10b981", "#f59e0b", "#3b82f6", "#ef4444", "#6b7280" },
                            borderWidth = 0
                        }
                    }
                },
                options = new
                {
                    responsive = true,
                    plugins = new
                    {
                        legend = new { position = "bottom" }
                    }
                }
            };

            await JSRuntime.InvokeVoidAsync("renderChart", "ticketStatusChart", statusConfig);

            // 2. Prepare Data for Hourly Chart (Bar)
            var hourlyData = filteredTickets
                .Where(t => t.CreatedAt != null)
                .GroupBy(t => t.CreatedAt.ToLocalTime().Hour)
                .OrderBy(g => g.Key)
                .Select(g => new { Hour = g.Key, Count = g.Count() })
                .ToList();

            var hours = Enumerable.Range(7, 11).ToList(); // 7 AM to 5 PM
            var hourlyCounts = hours.Select(h => hourlyData.FirstOrDefault(d => d.Hour == h)?.Count ?? 0).ToArray();
            var hourLabels = hours.Select(h => $"{h}:00").ToArray();

            var hourlyConfig = new
            {
                type = "bar",
                data = new
                {
                    labels = hourLabels,
                    datasets = new[]
                    {
                        new
                        {
                            label = "Tickets",
                            data = hourlyCounts,
                            backgroundColor = "#667eea",
                            borderRadius = 4
                        }
                    }
                },
                options = new
                {
                    responsive = true,
                    scales = new
                    {
                        y = new { beginAtZero = true }
                    }
                }
            };

            await JSRuntime.InvokeVoidAsync("renderChart", "ticketsByHourChart", hourlyConfig);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error rendering charts: {ex.Message}");
        }
    }

    private void ExportReport()
    {
        // TODO: Implement CSV/Excel export
        // For now, just show an alert
        Console.WriteLine("Export functionality to be implemented");
    }

    private string GetWaitTime(Ticket ticket)
    {
        if (ticket.CalledAt.HasValue && ticket.CompletedAt.HasValue)
        {
            var duration = ticket.CompletedAt.Value - ticket.CalledAt.Value;
            return $"{duration.TotalMinutes:F1} min";
        }
        return "-";
    }

    private string GetServiceDuration(Ticket ticket)
    {
        if (ticket.StartServiceTime.HasValue && ticket.EndServiceTime.HasValue)
        {
            var duration = ticket.EndServiceTime.Value - ticket.StartServiceTime.Value;
            if (duration.TotalSeconds < 60)
            {
                return $"{duration.TotalSeconds:F0}s";
            }
            return $"{duration.TotalMinutes:F1} min";
        }
        return "-";
    }
}
